buildscript {
  dependencies {
    classpath 'org.pongasoft:org.linkedin.gradle-plugins:2.2.9'
  }
}

plugins {
  id 'kotlin2js' version "1.3.40"
}

apply plugin: 'org.linkedin.spec'

group = spec.group
version = spec.version

/**
 * The org.linkedin.spec plugin dynamically changes the version if run with or
 * without the -Prelease=true argument, thus allowing to determine whether
 * dev mode or production mode
 */
def devMode = version.endsWith("-SNAPSHOT")

repositories {
  mavenCentral()
}

apply plugin: 'kotlin-dce-js'

def kotlinVersion = "1.3.40"

dependencies {
  compile "org.jetbrains.kotlin:kotlin-stdlib-js:$kotlinVersion"
  testImplementation "org.jetbrains.kotlin:kotlin-test-js:$kotlinVersion"
}

compileKotlin2Js {
  kotlinOptions {
    moduleKind = "umd"
    sourceMap = devMode
  }
}

// adding extension method child to File class
File.metaClass.child << { String c -> new File(delegate as File, c) }

if (devMode) {
  def webServerDockerImage = "$group/nginx/jamba-quickstart-frontend:$version"
  def webServerDockerContainer = "jamba-quickstart-frontend_webserver"

  def webDir = buildDir.child("web-dev")

  task assembleWeb(type: Sync) {
    configurations.compile.each { File file ->
      from(zipTree(file.absolutePath), {
        includeEmptyDirs = false
        include { fileTreeElement ->
          def path = fileTreeElement.path
          path.endsWith(".js") && (path.startsWith("META-INF/resources/") ||
              !path.startsWith("META-INF/"))
        }
      })
    }
    from compileKotlin2Js.destinationDir
    into webDir.child("js")

    dependsOn classes
  }

  assemble.dependsOn assembleWeb

  /**
   * Runs docker build to build an nginx web server (see Dockerfile for config) to serve static pages and
   * acts as a proxy for avoiding CORS issue with downloading assets from github
   */
  task webserverBuild(type: Exec) {
    workingDir file("webserver")
    commandLine(["docker", "build", "-t", webServerDockerImage, "."])
  }

  // I am sure there is a better way to get to this path but good luck finding it in the documentation...
  def resourcesDir = file('src/main/resources')

  /**
   * Runs the web server. Note that when running the task it just waits there and display log output or error. Using
   * CTRL-C to terminate will properly remove the container (option `--rm`).
   *
   * In dev mode, the server is run with 2 mounts:
   * - /s (for static) points directly in the source tree so that it is easy to simply edit/save the static file
   * - /d (for dynamic) points in the generated folder (can use assemble task to regenerate)
   */
  task 'webserver-start'(dependsOn: [assemble, webserverBuild], type: Exec) {
    commandLine(["docker", "run", "--rm", "--name", webServerDockerContainer, "-e", "TZ=America/Los_Angeles", "-p", "8080:80", "-v", "${resourcesDir.canonicalPath}:/usr/share/nginx/html/static:ro", "-v", "${webDir.canonicalPath}:/usr/share/nginx/html/dynamic:ro", webServerDockerImage])
  }

  /**
   * Stops the web server. Should not be needed but just in case...
   */
  task 'webserver-stop'(type: Exec) {
    commandLine(["docker", "container", "rm", webServerDockerContainer])
  }
} else {
  def webDir = buildDir.child("web")

  // prod mode
  // using `afterEvaluate` because `runDceKotlinJs.destinationDir` is `null` otherwise
  afterEvaluate {
    task assembleWeb(type: Sync, dependsOn: 'runDceKotlinJs') {
      from runDceKotlinJs.destinationDir
      exclude { it.name.endsWith(".map") }
      into webDir.child("js")
    }

    assemble.dependsOn assembleWeb
  }

  // also copy the static resources
  processResources {
    destinationDir webDir
  }
}